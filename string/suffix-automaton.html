<!DOCTYPE html>
<html lang="en" class="no-js">
  <!-- Mirrored from  firststeptocp.com/string/suffix-automaton.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 13 Mar 2022 18:44:40 GMT -->
  <meta http-equiv="content-type" content="text/html;charset=utf-8" />
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="icon" href="../favicon.ico" />
    <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-8.2.5" />

    <title>Suffix Automaton - Algorithms for Competitive Programming</title>

    <link rel="stylesheet" href="../assets/stylesheets/main.2d9f7617.min.css" />

    <link
      rel="stylesheet"
      href="../assets/stylesheets/palette.e6a45f82.min.css"
    />

    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback"
    />
    <style>
      :root {
        --md-text-font: "Roboto";
        --md-code-font: "Roboto Mono";
      }
    </style>

    <link rel="stylesheet" href="../stylesheets/extra.css" />

    <script>
      (__md_scope = new URL("..", location)),
        (__md_get = (e, _ = localStorage, t = __md_scope) =>
          JSON.parse(_.getItem(t.pathname + "." + e))),
        (__md_set = (e, _, t = localStorage, a = __md_scope) => {
          try {
            t.setItem(a.pathname + "." + e, JSON.stringify(_));
          } catch (e) {}
        });
    </script>

    <script>
      (window.ga =
        window.ga ||
        function () {
          (ga.q = ga.q || []).push(arguments);
        }),
        (ga.l = +new Date()),
        ga("create", "UA-85220282-1", "auto"),
        ga("set", "anonymizeIp", !0),
        ga("send", "pageview"),
        document.addEventListener("DOMContentLoaded", function () {
          document.forms.search &&
            document.forms.search.query.addEventListener("blur", function () {
              var e;
              this.value &&
                ((e = document.location.pathname),
                ga("send", "pageview", e + "?q=" + this.value));
            }),
            "undefined" != typeof location$ &&
              location$.subscribe(function (e) {
                ga("send", "pageview", e.pathname);
              });
        });
    </script>
    <script async src="../../www.google-analytics.com/analytics.js"></script>
  </head>

  <body
    dir="ltr"
    data-md-color-scheme="cpalgo"
    data-md-color-primary="deep-purple"
    data-md-color-accent=""
  >
    <script>
      var palette = __md_get("__palette");
      if (palette && "object" == typeof palette.color)
        for (var key of Object.keys(palette.color))
          document.body.setAttribute(
            "data-md-color-" + key,
            palette.color[key]
          );
    </script>

    <input
      class="md-toggle"
      data-md-toggle="drawer"
      type="checkbox"
      id="__drawer"
      autocomplete="off"
    />
    <input
      class="md-toggle"
      data-md-toggle="search"
      type="checkbox"
      id="__search"
      autocomplete="off"
    />
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      <a href="#suffix-automaton" class="md-skip"> Skip to content </a>
    </div>
    <div data-md-component="announce"></div>

    <!-- overwrite:
- scroll to top when clicking title
- go to main page when clicking the site title
- remove the menu button for mobile
-->

    <header class="md-header" data-md-component="header">
      <script>
        function scrollToTop() {
          document.body.scrollTop = 0; // For Safari
          document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        }
      </script>
      <nav class="md-header__inner md-grid" aria-label="Header">
        <a
          href="../index-2.html"
          title="Algorithms for Competitive Programming"
          class="md-header__button md-logo"
          aria-label="Algorithms for Competitive Programming"
          data-md-component="logo"
        >
          <img src="../favicon.ico" alt="logo" />
        </a>
        <div class="md-header__title" data-md-component="header-title">
          <div class="md-header__ellipsis">
            <div class="md-header__topic">
              <span class="md-ellipsis">
                <a
                  href="../index-2.html"
                  title="Algorithms for Competitive Programming"
                  aria-label="Algorithms for Competitive Programming"
                  data-md-component="logo"
                >
                  Algorithms for Competitive Programming
                </a>
              </span>
            </div>
            <div class="md-header__topic" data-md-component="header-topic">
              <span class="md-ellipsis">
                <a href="#" onclick="scrollToTop()"> Suffix Automaton </a>
              </span>
            </div>
          </div>
        </div>

        <form class="md-header__option" data-md-component="palette">
          <input
            class="md-option"
            data-md-color-media=""
            data-md-color-scheme="cpalgo"
            data-md-color-primary="deep-purple"
            data-md-color-accent=""
            aria-label="Switch to dark mode"
            type="radio"
            name="__palette"
            id="__palette_1"
          />

          <label
            class="md-header__button md-icon"
            title="Switch to dark mode"
            for="__palette_2"
            hidden
          >
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path
                d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
              />
            </svg>
          </label>

          <input
            class="md-option"
            data-md-color-media=""
            data-md-color-scheme="slate"
            data-md-color-primary=""
            data-md-color-accent=""
            aria-label="Switch to light mode"
            type="radio"
            name="__palette"
            id="__palette_2"
          />

          <label
            class="md-header__button md-icon"
            title="Switch to light mode"
            for="__palette_1"
            hidden
          >
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path
                d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z"
              />
            </svg>
          </label>
        </form>

        <label class="md-header__button md-icon" for="__search">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path
              d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"
            />
          </svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
          <label class="md-search__overlay" for="__search"></label>
        </div>
      </nav>
    </header>

    <div class="md-container" data-md-component="container">
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          <div
            class="md-sidebar md-sidebar--primary"
            data-md-component="sidebar"
            data-md-type="navigation"
          >
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav
                  class="md-nav md-nav--primary"
                  aria-label="Navigation"
                  data-md-level="0"
                >
                  <label class="md-nav__title" for="__drawer">
                    <a
                      href="../index-2.html"
                      title="Algorithms for Competitive Programming"
                      class="md-nav__button md-logo"
                      aria-label="Algorithms for Competitive Programming"
                      data-md-component="logo"
                    >
                      <img src="../favicon.ico" alt="logo" />
                    </a>
                    Algorithms for Competitive Programming
                  </label>

                  <ul class="md-nav__list" data-md-scrollfix>
                    <li class="md-nav__item">
                      <a href="../index-2.html" class="md-nav__link">
                        Main Page
                      </a>
                    </li>

                    <li class="md-nav__item">
                      <a href="../contrib.html" class="md-nav__link">
                        How to Contribute
                      </a>
                    </li>

                    <li class="md-nav__item">
                      <a href="../preview.html" class="md-nav__link">
                        Preview
                      </a>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_4"
                        type="checkbox"
                        id="__nav_4"
                      />

                      <label class="md-nav__link" for="__nav_4">
                        Algebra
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Algebra"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_4">
                          <span class="md-nav__icon md-icon"></span>
                          Algebra
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../algebra/all-submasks.html"
                              class="md-nav__link"
                            >
                              Submask Enumeration
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/balanced-ternary.html"
                              class="md-nav__link"
                            >
                              Balanced Ternary
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/big-integer.html"
                              class="md-nav__link"
                            >
                              Arbitrary-Precision Arithmetic
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/binary-exp.html"
                              class="md-nav__link"
                            >
                              Binary Exponentiation
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/chinese-remainder-theorem.html"
                              class="md-nav__link"
                            >
                              Chinese Remainder Theorem
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/discrete-log.html"
                              class="md-nav__link"
                            >
                              Discrete Logarithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/discrete-root.html"
                              class="md-nav__link"
                            >
                              Discrete Root
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/divisors.html"
                              class="md-nav__link"
                            >
                              Number of divisors / sum of divisors
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/euclid-algorithm.html"
                              class="md-nav__link"
                            >
                              Euclidean algorithm for computing the greatest
                              common divisor
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/extended-euclid-algorithm.html"
                              class="md-nav__link"
                            >
                              Extended Euclidean Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/factorial-divisors.html"
                              class="md-nav__link"
                            >
                              Finding Power of Factorial Divisor
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/factorial-modulo.html"
                              class="md-nav__link"
                            >
                              Factorial modulo p
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/factorization.html"
                              class="md-nav__link"
                            >
                              Integer factorization
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../algebra/fft.html" class="md-nav__link">
                              Fast Fourier transform
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/fibonacci-numbers.html"
                              class="md-nav__link"
                            >
                              Fibonacci Numbers
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/gray-code.html"
                              class="md-nav__link"
                            >
                              Gray code
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/linear-diophantine-equation.html"
                              class="md-nav__link"
                            >
                              Linear Diophantine Equation
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/linear_congruence_equation.html"
                              class="md-nav__link"
                            >
                              Linear Congruence Equation
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/module-inverse.html"
                              class="md-nav__link"
                            >
                              Modular Multiplicative Inverse
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/montgomery_multiplication.html"
                              class="md-nav__link"
                            >
                              Montgomery Multiplication
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/phi-function.html"
                              class="md-nav__link"
                            >
                              Euler's totient function
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/polynomial.html"
                              class="md-nav__link"
                            >
                              Operations on polynomials and series
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/primality_tests.html"
                              class="md-nav__link"
                            >
                              Primality tests
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/prime-sieve-linear.html"
                              class="md-nav__link"
                            >
                              Linear Sieve
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/primitive-root.html"
                              class="md-nav__link"
                            >
                              Primitive Root
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../algebra/sieve-of-eratosthenes.html"
                              class="md-nav__link"
                            >
                              Sieve of Eratosthenes
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_5"
                        type="checkbox"
                        id="__nav_5"
                      />

                      <label class="md-nav__link" for="__nav_5">
                        Combinatorics
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Combinatorics"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_5">
                          <span class="md-nav__icon md-icon"></span>
                          Combinatorics
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/binomial-coefficients.html"
                              class="md-nav__link"
                            >
                              Binomial Coefficients
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/bishops-on-chessboard.html"
                              class="md-nav__link"
                            >
                              Placing Bishops on a Chessboard
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/bracket_sequences.html"
                              class="md-nav__link"
                            >
                              Balanced bracket sequences
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/burnside.html"
                              class="md-nav__link"
                            >
                              Burnside's lemma / Pólya enumeration theorem
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/catalan-numbers.html"
                              class="md-nav__link"
                            >
                              Catalan Numbers
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/counting_labeled_graphs.html"
                              class="md-nav__link"
                            >
                              Counting labeled graphs
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/generating_combinations.html"
                              class="md-nav__link"
                            >
                              Generating all K-combinations
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/inclusion-exclusion.html"
                              class="md-nav__link"
                            >
                              The Inclusion-Exclusion Principle
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../combinatorics/stars_and_bars.html"
                              class="md-nav__link"
                            >
                              Stars and bars
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_6"
                        type="checkbox"
                        id="__nav_6"
                      />

                      <label class="md-nav__link" for="__nav_6">
                        Data structures
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Data structures"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_6">
                          <span class="md-nav__icon md-icon"></span>
                          Data structures
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../data_structures/deleting_in_log_n.html"
                              class="md-nav__link"
                            >
                              Deleting from a data structure in O(T(n)log n)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/disjoint_set_union.html"
                              class="md-nav__link"
                            >
                              Disjoint Set Union
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/fenwick.html"
                              class="md-nav__link"
                            >
                              Fenwick Tree
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/randomized_heap.html"
                              class="md-nav__link"
                            >
                              Randomized Heap
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/segment_tree.html"
                              class="md-nav__link"
                            >
                              Segment Tree
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/sparse-table.html"
                              class="md-nav__link"
                            >
                              Sparse Table
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/sqrt-tree.html"
                              class="md-nav__link"
                            >
                              Sqrt Tree
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/sqrt_decomposition.html"
                              class="md-nav__link"
                            >
                              Sqrt Decomposition
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/stack_queue_modification.html"
                              class="md-nav__link"
                            >
                              Minimum stack / Minimum queue
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../data_structures/treap.html"
                              class="md-nav__link"
                            >
                              Treap (Cartesian tree)
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_7"
                        type="checkbox"
                        id="__nav_7"
                      />

                      <label class="md-nav__link" for="__nav_7">
                        Dynamic programming
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Dynamic programming"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_7">
                          <span class="md-nav__icon md-icon"></span>
                          Dynamic programming
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../dynamic_programming/divide-and-conquer-dp.html"
                              class="md-nav__link"
                            >
                              Divide and Conquer DP
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../dynamic_programming/profile-dynamics.html"
                              class="md-nav__link"
                            >
                              Dynamic Programming on Broken Profile. Problem
                              "Parquet"
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../dynamic_programming/zero_matrix.html"
                              class="md-nav__link"
                            >
                              Finding the largest zero submatrix
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_8"
                        type="checkbox"
                        id="__nav_8"
                      />

                      <label class="md-nav__link" for="__nav_8">
                        Game theory
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Game theory"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_8">
                          <span class="md-nav__icon md-icon"></span>
                          Game theory
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../game_theory/games_on_graphs.html"
                              class="md-nav__link"
                            >
                              Games on arbitrary graphs
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../game_theory/sprague-grundy-nim.html"
                              class="md-nav__link"
                            >
                              Sprague-Grundy theorem. Nim
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_9"
                        type="checkbox"
                        id="__nav_9"
                      />

                      <label class="md-nav__link" for="__nav_9">
                        Geometry
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Geometry"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_9">
                          <span class="md-nav__icon md-icon"></span>
                          Geometry
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../geometry/area-of-simple-polygon.html"
                              class="md-nav__link"
                            >
                              Finding area of simple polygon in O(N)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/basic-geometry.html"
                              class="md-nav__link"
                            >
                              Basic Geometry
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/check-segments-intersection.html"
                              class="md-nav__link"
                            >
                              Check if two segments intersect
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/circle-circle-intersection.html"
                              class="md-nav__link"
                            >
                              Circle-Circle Intersection
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/circle-line-intersection.html"
                              class="md-nav__link"
                            >
                              Circle-Line Intersection
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/convex-hull.html"
                              class="md-nav__link"
                            >
                              Convex Hull construction
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/convex_hull_trick.html"
                              class="md-nav__link"
                            >
                              Convex hull trick and Li Chao tree
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/delaunay.html"
                              class="md-nav__link"
                            >
                              Delaunay triangulation and Voronoi diagram
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/halfplane-intersection.html"
                              class="md-nav__link"
                            >
                              Half-plane intersection
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/intersecting_segments.html"
                              class="md-nav__link"
                            >
                              Search for a pair of intersecting segments
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/lattice-points.html"
                              class="md-nav__link"
                            >
                              Lattice points inside non-lattice polygon
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/length-of-segments-union.html"
                              class="md-nav__link"
                            >
                              Length of the union of segments
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/lines-intersection.html"
                              class="md-nav__link"
                            >
                              Intersection Point of Lines
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/minkowski.html"
                              class="md-nav__link"
                            >
                              Minkowski sum of convex polygons
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/nearest_points.html"
                              class="md-nav__link"
                            >
                              Finding the nearest pair of points
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/oriented-triangle-area.html"
                              class="md-nav__link"
                            >
                              Oriented area of a triangle
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/picks-theorem.html"
                              class="md-nav__link"
                            >
                              Pick's Theorem
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/point-in-convex-polygon.html"
                              class="md-nav__link"
                            >
                              Check if point belongs to the convex polygon in
                              $O(\log N)$
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/point-location.html"
                              class="md-nav__link"
                            >
                              Point location in O(log n)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/segment-to-line.html"
                              class="md-nav__link"
                            >
                              Finding the equation of a line for a segment
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/segments-intersection.html"
                              class="md-nav__link"
                            >
                              Finding intersection of two segments
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/tangents-to-two-circles.html"
                              class="md-nav__link"
                            >
                              Finding common tangents to two circles
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../geometry/vertical_decomposition.html"
                              class="md-nav__link"
                            >
                              Vertical decomposition
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_10"
                        type="checkbox"
                        id="__nav_10"
                      />

                      <label class="md-nav__link" for="__nav_10">
                        Graph
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav class="md-nav" aria-label="Graph" data-md-level="1">
                        <label class="md-nav__title" for="__nav_10">
                          <span class="md-nav__icon md-icon"></span>
                          Graph
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a href="../graph/01_bfs.html" class="md-nav__link">
                              0-1 BFS
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../graph/2SAT.html" class="md-nav__link">
                              2-SAT
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/Assignment-problem-min-flow.html"
                              class="md-nav__link"
                            >
                              Solving assignment problem using min-cost-flow
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/all-pair-shortest-path-floyd-warshall.html"
                              class="md-nav__link"
                            >
                              Floyd-Warshall Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/bellman_ford.html"
                              class="md-nav__link"
                            >
                              Bellman-Ford Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/bipartite-check.html"
                              class="md-nav__link"
                            >
                              Check whether a graph is bipartite
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/breadth-first-search.html"
                              class="md-nav__link"
                            >
                              Breadth-first search
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/bridge-searching-online.html"
                              class="md-nav__link"
                            >
                              Finding Bridges Online
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/bridge-searching.html"
                              class="md-nav__link"
                            >
                              Finding bridges in a graph in O(N+M)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/cutpoints.html"
                              class="md-nav__link"
                            >
                              Finding articulation points in a graph in O(N+M)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/depth-first-search.html"
                              class="md-nav__link"
                            >
                              Depth First Search
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/desopo_pape.html"
                              class="md-nav__link"
                            >
                              D´Esopo-Pape algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/dijkstra.html"
                              class="md-nav__link"
                            >
                              Dijkstra Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/dijkstra_sparse.html"
                              class="md-nav__link"
                            >
                              Dijkstra on sparse graphs
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../graph/dinic.html" class="md-nav__link">
                              Maximum flow - Dinic's algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/edge_vertex_connectivity.html"
                              class="md-nav__link"
                            >
                              Edge connectivity / Vertex connectivity
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/edmonds_karp.html"
                              class="md-nav__link"
                            >
                              Maximum flow - Ford-Fulkerson and Edmonds-Karp
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/euler_path.html"
                              class="md-nav__link"
                            >
                              Finding the Eulerian path in O(M)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/finding-cycle.html"
                              class="md-nav__link"
                            >
                              Checking a graph for acyclicity and finding a
                              cycle in O(M)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/finding-negative-cycle-in-graph.html"
                              class="md-nav__link"
                            >
                              Finding a negative cycle in the graph
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/fixed_length_paths.html"
                              class="md-nav__link"
                            >
                              Number of paths of fixed length / Shortest paths
                              of fixed length
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/flow_with_demands.html"
                              class="md-nav__link"
                            >
                              Flows with demands
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../graph/hld.html" class="md-nav__link">
                              Heavy-light decomposition
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/kirchhoff-theorem.html"
                              class="md-nav__link"
                            >
                              Kirchhoff's theorem. Finding the number of
                              spanning trees
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/kuhn_maximum_bipartite_matching.html"
                              class="md-nav__link"
                            >
                              Kuhn's Algorithm for Maximum Bipartite Matching
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../graph/lca.html" class="md-nav__link">
                              Lowest Common Ancestor - O(sqrt(N)) and O(log N)
                              with O(N) preprocessing
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/lca_binary_lifting.html"
                              class="md-nav__link"
                            >
                              Lowest Common Ancestor - Binary Lifting
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/lca_farachcoltonbender.html"
                              class="md-nav__link"
                            >
                              Lowest Common Ancestor - Farach-Colton and Bender
                              Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/lca_tarjan.html"
                              class="md-nav__link"
                            >
                              Lowest Common Ancestor - Tarjan's off-line
                              algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/min_cost_flow.html"
                              class="md-nav__link"
                            >
                              Minimum-cost flow - Successive shortest path
                              algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="../graph/mpm.html" class="md-nav__link">
                              Maximum flow - MPM algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/mst_kruskal.html"
                              class="md-nav__link"
                            >
                              Minimum spanning tree - Kruskal's algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/mst_kruskal_with_dsu.html"
                              class="md-nav__link"
                            >
                              Minimum spanning tree - Kruskal with Disjoint Set
                              Union
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/mst_prim.html"
                              class="md-nav__link"
                            >
                              Minimum spanning tree - Prim's algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/pruefer_code.html"
                              class="md-nav__link"
                            >
                              Prüfer code
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/push-relabel-faster.html"
                              class="md-nav__link"
                            >
                              Maximum flow - Push-relabel method improved
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/push-relabel.html"
                              class="md-nav__link"
                            >
                              Maximum flow - Push-relabel algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/rmq_linear.html"
                              class="md-nav__link"
                            >
                              Solve RMQ (Range Minimum Query) by finding LCA
                              (Lowest Common Ancestor)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/search-for-connected-components.html"
                              class="md-nav__link"
                            >
                              Search for connected components in a graph
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/second_best_mst.html"
                              class="md-nav__link"
                            >
                              Second Best Minimum Spanning Tree
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/strong-orientation.html"
                              class="md-nav__link"
                            >
                              Strong Orientation
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/strongly-connected-components.html"
                              class="md-nav__link"
                            >
                              Finding strongly connected components / Building
                              condensation graph
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/topological-sort.html"
                              class="md-nav__link"
                            >
                              Topological Sorting
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../graph/tree_painting.html"
                              class="md-nav__link"
                            >
                              Paint the edges of the tree
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_11"
                        type="checkbox"
                        id="__nav_11"
                      />

                      <label class="md-nav__link" for="__nav_11">
                        Linear algebra
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Linear algebra"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_11">
                          <span class="md-nav__icon md-icon"></span>
                          Linear algebra
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../linear_algebra/determinant-gauss.html"
                              class="md-nav__link"
                            >
                              Calculating the determinant of a matrix by Gauss
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../linear_algebra/determinant-kraut.html"
                              class="md-nav__link"
                            >
                              Calculating the determinant using Kraut method
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../linear_algebra/linear-system-gauss.html"
                              class="md-nav__link"
                            >
                              Gauss method for solving system of linear
                              equations
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../linear_algebra/rank-matrix.html"
                              class="md-nav__link"
                            >
                              Finding the rank of a matrix
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_12"
                        type="checkbox"
                        id="__nav_12"
                      />

                      <label class="md-nav__link" for="__nav_12">
                        Num methods
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Num methods"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_12">
                          <span class="md-nav__icon md-icon"></span>
                          Num methods
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../num_methods/roots_newton.html"
                              class="md-nav__link"
                            >
                              Newton's method for finding roots
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../num_methods/simpson-integration.html"
                              class="md-nav__link"
                            >
                              Integration by Simpson's formula
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../num_methods/ternary_search.html"
                              class="md-nav__link"
                            >
                              Ternary Search
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_13"
                        type="checkbox"
                        id="__nav_13"
                      />

                      <label class="md-nav__link" for="__nav_13">
                        Others
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav class="md-nav" aria-label="Others" data-md-level="1">
                        <label class="md-nav__title" for="__nav_13">
                          <span class="md-nav__icon md-icon"></span>
                          Others
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../others/15-puzzle.html"
                              class="md-nav__link"
                            >
                              15 Puzzle Game: Existence Of The Solution
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../others/josephus_problem.html"
                              class="md-nav__link"
                            >
                              Josephus Problem
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../others/maximum_average_segment.html"
                              class="md-nav__link"
                            >
                              Search the subarray with the maximum/minimum sum
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../others/stern_brocot_tree_farey_sequences.html"
                              class="md-nav__link"
                            >
                              The Stern-Brocot tree and Farey sequences
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_14"
                        type="checkbox"
                        id="__nav_14"
                      />

                      <label class="md-nav__link" for="__nav_14">
                        Schedules
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Schedules"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_14">
                          <span class="md-nav__icon md-icon"></span>
                          Schedules
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../schedules/schedule-with-completion-duration.html"
                              class="md-nav__link"
                            >
                              Optimal schedule of jobs given their deadlines and
                              durations
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../schedules/schedule_one_machine.html"
                              class="md-nav__link"
                            >
                              Scheduling jobs on one machine
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../schedules/schedule_two_machines.html"
                              class="md-nav__link"
                            >
                              Scheduling jobs on two machines
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item md-nav__item--nested">
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_15"
                        type="checkbox"
                        id="__nav_15"
                      />

                      <label class="md-nav__link" for="__nav_15">
                        Sequences
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav
                        class="md-nav"
                        aria-label="Sequences"
                        data-md-level="1"
                      >
                        <label class="md-nav__title" for="__nav_15">
                          <span class="md-nav__icon md-icon"></span>
                          Sequences
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a
                              href="../sequences/k-th.html"
                              class="md-nav__link"
                            >
                              K-th order statistic in O(N)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../sequences/longest_increasing_subsequence.html"
                              class="md-nav__link"
                            >
                              Longest increasing subsequence
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="../sequences/rmq.html"
                              class="md-nav__link"
                            >
                              Range Minimum Query
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li
                      class="md-nav__item md-nav__item--active md-nav__item--nested"
                    >
                      <input
                        class="md-nav__toggle md-toggle"
                        data-md-toggle="__nav_16"
                        type="checkbox"
                        id="__nav_16"
                        checked
                      />

                      <label class="md-nav__link" for="__nav_16">
                        String
                        <span class="md-nav__icon md-icon"></span>
                      </label>

                      <nav class="md-nav" aria-label="String" data-md-level="1">
                        <label class="md-nav__title" for="__nav_16">
                          <span class="md-nav__icon md-icon"></span>
                          String
                        </label>
                        <ul class="md-nav__list" data-md-scrollfix>
                          <li class="md-nav__item">
                            <a href="aho_corasick.html" class="md-nav__link">
                              Aho-Corasick algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="expression_parsing.html"
                              class="md-nav__link"
                            >
                              Expression parsing
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="lyndon_factorization.html"
                              class="md-nav__link"
                            >
                              Lyndon factorization
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="main_lorentz.html" class="md-nav__link">
                              Finding repetitions
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="manacher.html" class="md-nav__link">
                              Manacher's Algorithm - Finding all sub-palindromes
                              in O(N)
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="prefix-function.html" class="md-nav__link">
                              Prefix function. Knuth–Morris–Pratt algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="rabin-karp.html" class="md-nav__link">
                              Rabin-Karp Algorithm for string matching
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="string-hashing.html" class="md-nav__link">
                              String Hashing
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="suffix-array.html" class="md-nav__link">
                              Suffix Array
                            </a>
                          </li>

                          <li class="md-nav__item md-nav__item--active">
                            <input
                              class="md-nav__toggle md-toggle"
                              data-md-toggle="toc"
                              type="checkbox"
                              id="__toc"
                            />

                            <label
                              class="md-nav__link md-nav__link--active"
                              for="__toc"
                            >
                              Suffix Automaton
                              <span class="md-nav__icon md-icon"></span>
                            </label>

                            <a
                              href="suffix-automaton.html"
                              class="md-nav__link md-nav__link--active"
                            >
                              Suffix Automaton
                            </a>

                            <nav
                              class="md-nav md-nav--secondary"
                              aria-label="Table of contents"
                            >
                              <label class="md-nav__title" for="__toc">
                                <span class="md-nav__icon md-icon"></span>
                                Table of contents
                              </label>
                              <ul
                                class="md-nav__list"
                                data-md-component="toc"
                                data-md-scrollfix
                              >
                                <li class="md-nav__item">
                                  <a
                                    href="#definition-of-a-suffix-automaton"
                                    class="md-nav__link"
                                  >
                                    Definition of a suffix automaton
                                  </a>

                                  <nav
                                    class="md-nav"
                                    aria-label="Definition of a suffix automaton"
                                  >
                                    <ul class="md-nav__list">
                                      <li class="md-nav__item">
                                        <a
                                          href="#substring-property"
                                          class="md-nav__link"
                                        >
                                          Substring property
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#examples-of-constructed-suffix-automata"
                                          class="md-nav__link"
                                        >
                                          Examples of constructed suffix
                                          automata
                                        </a>
                                      </li>
                                    </ul>
                                  </nav>
                                </li>

                                <li class="md-nav__item">
                                  <a
                                    href="#construction-in-linear-time"
                                    class="md-nav__link"
                                  >
                                    Construction in linear time
                                  </a>

                                  <nav
                                    class="md-nav"
                                    aria-label="Construction in linear time"
                                  >
                                    <ul class="md-nav__list">
                                      <li class="md-nav__item">
                                        <a
                                          href="#end-positions-endpos"
                                          class="md-nav__link"
                                        >
                                          End positions
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#suffix-links-link"
                                          class="md-nav__link"
                                        >
                                          Suffix links
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a href="#recap" class="md-nav__link">
                                          Recap
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#algorithm"
                                          class="md-nav__link"
                                        >
                                          Algorithm
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#correctness"
                                          class="md-nav__link"
                                        >
                                          Correctness
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#linear-number-of-operations"
                                          class="md-nav__link"
                                        >
                                          Linear number of operations
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#implementation"
                                          class="md-nav__link"
                                        >
                                          Implementation
                                        </a>
                                      </li>
                                    </ul>
                                  </nav>
                                </li>

                                <li class="md-nav__item">
                                  <a
                                    href="#additional-properties"
                                    class="md-nav__link"
                                  >
                                    Additional properties
                                  </a>

                                  <nav
                                    class="md-nav"
                                    aria-label="Additional properties"
                                  >
                                    <ul class="md-nav__list">
                                      <li class="md-nav__item">
                                        <a
                                          href="#number-of-states"
                                          class="md-nav__link"
                                        >
                                          Number of states
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#number-of-transitions"
                                          class="md-nav__link"
                                        >
                                          Number of transitions
                                        </a>
                                      </li>
                                    </ul>
                                  </nav>
                                </li>

                                <li class="md-nav__item">
                                  <a href="#applications" class="md-nav__link">
                                    Applications
                                  </a>

                                  <nav class="md-nav" aria-label="Applications">
                                    <ul class="md-nav__list">
                                      <li class="md-nav__item">
                                        <a
                                          href="#check-for-occurrence"
                                          class="md-nav__link"
                                        >
                                          Check for occurrence
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#number-of-different-substrings"
                                          class="md-nav__link"
                                        >
                                          Number of different substrings
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#total-length-of-all-different-substrings"
                                          class="md-nav__link"
                                        >
                                          Total length of all different
                                          substrings
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#lexicographically-k-th-substring"
                                          class="md-nav__link"
                                        >
                                          Lexicographically k-th substring
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#smallest-cyclic-shift"
                                          class="md-nav__link"
                                        >
                                          Smallest cyclic shift
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#number-of-occurrences"
                                          class="md-nav__link"
                                        >
                                          Number of occurrences
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#first-occurrence-position"
                                          class="md-nav__link"
                                        >
                                          First occurrence position
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#all-occurrence-positions"
                                          class="md-nav__link"
                                        >
                                          All occurrence positions
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#shortest-non-appearing-string"
                                          class="md-nav__link"
                                        >
                                          Shortest non-appearing string
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#longest-common-substring-of-two-strings"
                                          class="md-nav__link"
                                        >
                                          Longest common substring of two
                                          strings
                                        </a>
                                      </li>

                                      <li class="md-nav__item">
                                        <a
                                          href="#largest-common-substring-of-multiple-strings"
                                          class="md-nav__link"
                                        >
                                          Largest common substring of multiple
                                          strings
                                        </a>
                                      </li>
                                    </ul>
                                  </nav>
                                </li>

                                <li class="md-nav__item">
                                  <a
                                    href="#practice-problems"
                                    class="md-nav__link"
                                  >
                                    Practice Problems
                                  </a>
                                </li>
                              </ul>
                            </nav>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="suffix-tree-ukkonen.html"
                              class="md-nav__link"
                            >
                              Suffix Tree. Ukkonen's Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="z-function.html" class="md-nav__link">
                              Z-function and its calculation
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>
                  </ul>
                </nav>
              </div>
            </div>
          </div>

          <div
            class="md-sidebar md-sidebar--secondary"
            data-md-component="sidebar"
            data-md-type="toc"
          >
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav
                  class="md-nav md-nav--secondary"
                  aria-label="Table of contents"
                >
                  <label class="md-nav__title" for="__toc">
                    <span class="md-nav__icon md-icon"></span>
                    Table of contents
                  </label>
                  <ul
                    class="md-nav__list"
                    data-md-component="toc"
                    data-md-scrollfix
                  >
                    <li class="md-nav__item">
                      <a
                        href="#definition-of-a-suffix-automaton"
                        class="md-nav__link"
                      >
                        Definition of a suffix automaton
                      </a>

                      <nav
                        class="md-nav"
                        aria-label="Definition of a suffix automaton"
                      >
                        <ul class="md-nav__list">
                          <li class="md-nav__item">
                            <a href="#substring-property" class="md-nav__link">
                              Substring property
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#examples-of-constructed-suffix-automata"
                              class="md-nav__link"
                            >
                              Examples of constructed suffix automata
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item">
                      <a
                        href="#construction-in-linear-time"
                        class="md-nav__link"
                      >
                        Construction in linear time
                      </a>

                      <nav
                        class="md-nav"
                        aria-label="Construction in linear time"
                      >
                        <ul class="md-nav__list">
                          <li class="md-nav__item">
                            <a
                              href="#end-positions-endpos"
                              class="md-nav__link"
                            >
                              End positions
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="#suffix-links-link" class="md-nav__link">
                              Suffix links
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="#recap" class="md-nav__link"> Recap </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="#algorithm" class="md-nav__link">
                              Algorithm
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="#correctness" class="md-nav__link">
                              Correctness
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#linear-number-of-operations"
                              class="md-nav__link"
                            >
                              Linear number of operations
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a href="#implementation" class="md-nav__link">
                              Implementation
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item">
                      <a href="#additional-properties" class="md-nav__link">
                        Additional properties
                      </a>

                      <nav class="md-nav" aria-label="Additional properties">
                        <ul class="md-nav__list">
                          <li class="md-nav__item">
                            <a href="#number-of-states" class="md-nav__link">
                              Number of states
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#number-of-transitions"
                              class="md-nav__link"
                            >
                              Number of transitions
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item">
                      <a href="#applications" class="md-nav__link">
                        Applications
                      </a>

                      <nav class="md-nav" aria-label="Applications">
                        <ul class="md-nav__list">
                          <li class="md-nav__item">
                            <a
                              href="#check-for-occurrence"
                              class="md-nav__link"
                            >
                              Check for occurrence
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#number-of-different-substrings"
                              class="md-nav__link"
                            >
                              Number of different substrings
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#total-length-of-all-different-substrings"
                              class="md-nav__link"
                            >
                              Total length of all different substrings
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#lexicographically-k-th-substring"
                              class="md-nav__link"
                            >
                              Lexicographically k-th substring
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#smallest-cyclic-shift"
                              class="md-nav__link"
                            >
                              Smallest cyclic shift
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#number-of-occurrences"
                              class="md-nav__link"
                            >
                              Number of occurrences
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#first-occurrence-position"
                              class="md-nav__link"
                            >
                              First occurrence position
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#all-occurrence-positions"
                              class="md-nav__link"
                            >
                              All occurrence positions
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#shortest-non-appearing-string"
                              class="md-nav__link"
                            >
                              Shortest non-appearing string
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#longest-common-substring-of-two-strings"
                              class="md-nav__link"
                            >
                              Longest common substring of two strings
                            </a>
                          </li>

                          <li class="md-nav__item">
                            <a
                              href="#largest-common-substring-of-multiple-strings"
                              class="md-nav__link"
                            >
                              Largest common substring of multiple strings
                            </a>
                          </li>
                        </ul>
                      </nav>
                    </li>

                    <li class="md-nav__item">
                      <a href="#practice-problems" class="md-nav__link">
                        Practice Problems
                      </a>
                    </li>
                  </ul>
                </nav>
              </div>
            </div>
          </div>

          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              <script type="text/javascript">
                window.onload = function () {
                  const newIssueURL =
                    "https://github.com/e-maxx-eng/e-maxx-eng/issues/new";
                  const issueTitle = `Problem on article "Suffix Automaton"`;
                  const issueBody = `
 **Article:** [Suffix Automaton](${window.location.href})

**Problem:**
<!--
Describe the issue of this article in detail.
-->
`;
                  var issue_a = document.getElementById("report_issue_a");
                  issue_a.href =
                    `${newIssueURL}?` +
                    `title=${encodeURIComponent(issueTitle)}&` +
                    `body=${encodeURIComponent(issueBody)}`;
                };
              </script>

              <h1 id="suffix-automaton">Suffix Automaton</h1>
              <p>
                A <strong>suffix automaton</strong> is a powerful data structure
                that allows solving many string-related problems.
              </p>
              <p>
                For example, you can search for all occurrences of one string in
                another, or count the amount of different substrings of a given
                string. Both tasks can be solved in linear time with the help of
                a suffix automaton.
              </p>
              <p>
                Intuitively a suffix automaton can be understood as a compressed
                form of <strong>all substrings</strong> of a given string. An
                impressive fact is, that the suffix automaton contains all this
                information in a highly compressed form. For a string of length
                <span class="arithmatex">\(n\)</span> it only requires
                <span class="arithmatex">\(O(n)\)</span> memory. Moreover, it
                can also be built in
                <span class="arithmatex">\(O(n)\)</span> time (if we consider
                the size <span class="arithmatex">\(k\)</span> of the alphabet
                as a constant), otherwise both the memory and the time
                complexity will be
                <span class="arithmatex">\(O(n \log k)\)</span>.
              </p>
              <p>
                The linearity of the size of the suffix automaton was first
                discovered in 1983 by Blumer et al., and in 1985 the first
                linear algorithms for the construction was presented by
                Crochemore and Blumer.
              </p>
              <h2 id="definition-of-a-suffix-automaton">
                Definition of a suffix automaton
              </h2>
              <p>
                A suffix automaton for a given string
                <span class="arithmatex">\(s\)</span> is a minimal
                <strong>DFA</strong> (deterministic finite automaton /
                deterministic finite state machine) that accepts all the
                suffixes of the string <span class="arithmatex">\(s\)</span>.
              </p>
              <p>In other words:</p>
              <ul>
                <li>
                  A suffix automaton is an oriented acyclic graph. The vertices
                  are called <strong>states</strong>, and the edges are called
                  <strong>transitions</strong> between states.
                </li>
                <li>
                  One of the states <span class="arithmatex">\(t_0\)</span> is
                  the <strong>initial state</strong>, and it must be the source
                  of the graph (all other states are reachable from
                  <span class="arithmatex">\(t_0\)</span>).
                </li>
                <li>
                  Each <strong>transition</strong> is labeled with some
                  character. All transitions originating from a state must have
                  <strong>different</strong> labels.
                </li>
                <li>
                  One or multiple states are marked as
                  <strong>terminal states</strong>. If we start from the initial
                  state <span class="arithmatex">\(t_0\)</span> and move along
                  transitions to a terminal state, then the labels of the passed
                  transitions must spell one of the suffixes of the string
                  <span class="arithmatex">\(s\)</span>. Each of the suffixes of
                  <span class="arithmatex">\(s\)</span> must be spellable using
                  a path from <span class="arithmatex">\(t_0\)</span> to a
                  terminal state.
                </li>
                <li>
                  The suffix automaton contains the minimum number of vertices
                  among all automata satisfying the conditions described above.
                </li>
              </ul>
              <h3 id="substring-property">Substring property</h3>
              <p>
                The simplest and most important property of a suffix automaton
                is, that it contains information about all substrings of the
                string <span class="arithmatex">\(s\)</span>. Any path starting
                at the initial state <span class="arithmatex">\(t_0\)</span>, if
                we write down the labels of the transitions, forms a
                <strong>substring</strong> of
                <span class="arithmatex">\(s\)</span>. And conversely every
                substring of <span class="arithmatex">\(s\)</span> corresponds
                to a certain path starting at
                <span class="arithmatex">\(t_0\)</span>.
              </p>
              <p>
                In order to simplify the explanations, we will say that the
                substring <strong>corresponds</strong> to that path (starting at
                <span class="arithmatex">\(t_0\)</span> and the labels spell the
                substring). And conversely we say that any path
                <strong>corresponds</strong> to the string spelled by its
                labels.
              </p>
              <p>
                One or multiple paths can lead to a state. Thus, we will say
                that a state <strong>corresponds</strong> to the set of strings,
                which correspond to these paths.
              </p>
              <h3 id="examples-of-constructed-suffix-automata">
                Examples of constructed suffix automata
              </h3>
              <p>
                Here we will show some examples of suffix automata for several
                simple strings.
              </p>
              <p>
                We will denote the initial state with blue and the terminal
                states with green.
              </p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{""}\)</span>:
              </p>
              <p><img alt='Suffix automaton for ""' src="SA.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"a"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "a"' src="SAa.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"aa"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "aa"' src="SAaa.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"ab"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "ab"' src="SAab.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"aba"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "aba"' src="SAaba.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"abb"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "abb"' src="SAabb.png" /></p>
              <p>
                For the string
                <span class="arithmatex">\(s =~ \text{"abbb"}\)</span>:
              </p>
              <p><img alt='Suffix automaton for "abbb"' src="SAabbb.png" /></p>
              <h2 id="construction-in-linear-time">
                Construction in linear time
              </h2>
              <p>
                Before we describe the algorithm to construct a suffix automaton
                in linear time, we need to introduce several new concepts and
                simple proofs, which will be very important in understanding the
                construction.
              </p>
              <h3 id="end-positions-endpos">
                End positions <span class="arithmatex">\(endpos\)</span>
              </h3>
              <p>
                Consider any non-empty substring
                <span class="arithmatex">\(t\)</span> of the string
                <span class="arithmatex">\(s\)</span>. We will denote with
                <span class="arithmatex">\(endpos(t)\)</span> the set of all
                positions in the string <span class="arithmatex">\(s\)</span>,
                in which the occurrences of
                <span class="arithmatex">\(t\)</span> end. For instance, we have
                <span class="arithmatex"
                  >\(endpos(\text{"bc"}) = \{2, 4\}\)</span
                >
                for the string
                <span class="arithmatex">\(\text{"abcbc"}\)</span>.
              </p>
              <p>
                We will call two substrings
                <span class="arithmatex">\(t_1\)</span> and
                <span class="arithmatex">\(t_2\)</span>
                <span class="arithmatex">\(endpos\)</span>-equivalent, if their
                ending sets coincide:
                <span class="arithmatex">\(endpos(t_1) = endpos(t_2)\)</span>.
                Thus all non-empty substrings of the string
                <span class="arithmatex">\(s\)</span> can be decomposed into
                several <strong>equivalence classes</strong> according to their
                sets <span class="arithmatex">\(endpos\)</span>.
              </p>
              <p>
                It turns out, that in a suffix machine
                <span class="arithmatex">\(endpos\)</span>-equivalent substrings
                <strong>correspond to the same state</strong>. In other words
                the number of states in a suffix automaton is equal to the
                number of equivalence classes among all substrings, plus the
                initial state. Each state of a suffix automaton corresponds to
                one or more substrings having the same value
                <span class="arithmatex">\(endpos\)</span>.
              </p>
              <p>
                We will later describe the construction algorithm using this
                assumption. We will then see, that all the required properties
                of a suffix automaton, except for the minimality, are fulfilled.
                And the minimality follows from Nerode's theorem (which will not
                be proven in this article).
              </p>
              <p>
                We can make some important observations concerning the values
                <span class="arithmatex">\(endpos\)</span>:
              </p>
              <p>
                <strong>Lemma 1</strong>: Two non-empty substrings
                <span class="arithmatex">\(u\)</span> and
                <span class="arithmatex">\(w\)</span> (with
                <span class="arithmatex">\(length(u) \le length(w)\)</span>) are
                <span class="arithmatex">\(endpos\)</span>-equivalent, if and
                only if the string <span class="arithmatex">\(u\)</span> occurs
                in <span class="arithmatex">\(s\)</span> only in the form of a
                suffix of <span class="arithmatex">\(w\)</span>.
              </p>
              <p>
                The proof is obvious. If
                <span class="arithmatex">\(u\)</span> and
                <span class="arithmatex">\(w\)</span> have the same
                <span class="arithmatex">\(endpos\)</span> values, then
                <span class="arithmatex">\(u\)</span> is a suffix of
                <span class="arithmatex">\(w\)</span> and appears only in the
                form of a suffix of <span class="arithmatex">\(w\)</span> in
                <span class="arithmatex">\(s\)</span>. And if
                <span class="arithmatex">\(u\)</span> is a suffix of
                <span class="arithmatex">\(w\)</span> and appears only in the
                form as a suffix in <span class="arithmatex">\(s\)</span>, then
                the values <span class="arithmatex">\(endpos\)</span> are equal
                by definition.
              </p>
              <p>
                <strong>Lemma 2</strong>: Consider two non-empty substrings
                <span class="arithmatex">\(u\)</span> and
                <span class="arithmatex">\(w\)</span> (with
                <span class="arithmatex">\(length(u) \le length(w)\)</span>).
                Then their sets
                <span class="arithmatex">\(endpos\)</span> either don't
                intersect at all, or
                <span class="arithmatex">\(endpos(w)\)</span> is a subset of
                <span class="arithmatex">\(endpos(u)\)</span>. And it depends on
                if <span class="arithmatex">\(u\)</span> is a suffix of
                <span class="arithmatex">\(w\)</span> or not.
              </p>
              <div class="arithmatex">
                \[\begin{cases} endpos(w) \subseteq endpos(u) &amp; \text{if } u
                \text{ is a suffix of } w \\\\ endpos(w) \cap endpos(u) =
                \emptyset &amp; \text{otherwise} \end{cases}\]
              </div>
              <p>
                Proof: If the sets
                <span class="arithmatex">\(endpos(u)\)</span> and
                <span class="arithmatex">\(endpos(w)\)</span> have at least one
                common element, then the strings
                <span class="arithmatex">\(u\)</span> and
                <span class="arithmatex">\(w\)</span> both end in that position,
                i.e. <span class="arithmatex">\(u\)</span> is a suffix of
                <span class="arithmatex">\(w\)</span>. But then at every
                occurrence of <span class="arithmatex">\(w\)</span> also appears
                the substring <span class="arithmatex">\(u\)</span>, which means
                that <span class="arithmatex">\(endpos(w)\)</span> is a subset
                of <span class="arithmatex">\(endpos(u)\)</span>.
              </p>
              <p>
                <strong>Lemma 3</strong>: Consider an
                <span class="arithmatex">\(endpos\)</span>-equivalence class.
                Sort all the substrings in this class by decreasing length. Then
                in the resulting sequence each substring will be one shorter
                than the previous one, and at the same time will be a suffix of
                the previous one. In other words, in a same equivalence class,
                the shorter substrings are actually suffixes of the longer
                substrings, and they take all possible lengths in a certain
                interval <span class="arithmatex">\([x; y]\)</span>.
              </p>
              <p>
                Proof: Fix some
                <span class="arithmatex">\(endpos\)</span>-equivalence class. If
                it only contains one string, then the lemma is obviously true.
                Now let's say that the number of strings in the class is greater
                than one.
              </p>
              <p>
                According to Lemma 1, two different
                <span class="arithmatex">\(endpos\)</span>-equivalent strings
                are always in such a way, that the shorter one is a proper
                suffix of the longer one. Consequently, there cannot be two
                strings of the same length in the equivalence class.
              </p>
              <p>
                Let's denote by <span class="arithmatex">\(w\)</span> the
                longest, and through <span class="arithmatex">\(u\)</span> the
                shortest string in the equivalence class. According to Lemma 1,
                the string <span class="arithmatex">\(u\)</span> is a proper
                suffix of the string <span class="arithmatex">\(w\)</span>.
                Consider now any suffix of
                <span class="arithmatex">\(w\)</span> with a length in the
                interval
                <span class="arithmatex">\([length(u); length(w)]\)</span>. It
                is easy to see, that this suffix is also contained in the same
                equivalence class. Because this suffix can only appear in the
                form of a suffix of <span class="arithmatex">\(w\)</span> in the
                string <span class="arithmatex">\(s\)</span> (since also the
                shorter suffix <span class="arithmatex">\(u\)</span> occurs in
                <span class="arithmatex">\(s\)</span> only in the form of a
                suffix of <span class="arithmatex">\(w\)</span>). Consequently,
                according to Lemma 1, this suffix is
                <span class="arithmatex">\(endpos\)</span>-equivalent to the
                string <span class="arithmatex">\(w\)</span>.
              </p>
              <h3 id="suffix-links-link">
                Suffix links <span class="arithmatex">\(link\)</span>
              </h3>
              <p>
                Consider some state
                <span class="arithmatex">\(v \ne t_0\)</span> in the automaton.
                As we know, the state
                <span class="arithmatex">\(v\)</span> corresponds to the class
                of strings with the same
                <span class="arithmatex">\(endpos\)</span> values. And if we
                denote by <span class="arithmatex">\(w\)</span> the longest of
                these strings, then all the other strings are suffixes of
                <span class="arithmatex">\(w\)</span>.
              </p>
              <p>
                We also know the first few suffixes of a string
                <span class="arithmatex">\(w\)</span> (if we consider suffixes
                in descending order of their length) are all contained in this
                equivalence class, and all other suffixes (at least one other -
                the empty suffix) are in some other classes. We denote by
                <span class="arithmatex">\(t\)</span> the biggest such suffix,
                and make a suffix link to it.
              </p>
              <p>
                In other words, a <strong>suffix link</strong>
                <span class="arithmatex">\(link(v)\)</span> leads to the state
                that corresponds to the <strong>longest suffix</strong> of
                <span class="arithmatex">\(w\)</span> that is in another
                <span class="arithmatex">\(endpos\)</span>-equivalence class.
              </p>
              <p>
                Here we assume that the initial state
                <span class="arithmatex">\(t_0\)</span> corresponds to its own
                equivalence class (containing only the empty string), and for
                convenience we set
                <span class="arithmatex"
                  >\(endpos(t_0) = \{-1, 0, \dots, length(s)-1\}\)</span
                >.
              </p>
              <p>
                <strong>Lemma 4</strong>: Suffix links form a
                <strong>tree</strong> with the root
                <span class="arithmatex">\(t_0\)</span>.
              </p>
              <p>
                Proof: Consider an arbitrary state
                <span class="arithmatex">\(v \ne t_0\)</span>. A suffix link
                <span class="arithmatex">\(link(v)\)</span> leads to a state
                corresponding to strings with strictly smaller length (this
                follows from the definition of the suffix links and from Lemma
                3). Therefore, by moving along the suffix links, we will sooner
                or later come to the initial state
                <span class="arithmatex">\(t_0\)</span>, which corresponds to
                the empty string.
              </p>
              <p>
                <strong>Lemma 5</strong>: If we construct a tree using the sets
                <span class="arithmatex">\(endpos\)</span> (by the rule that the
                set of a parent node contains the sets of all children as
                subsets), then the structure will coincide with the tree of
                suffix links.
              </p>
              <p>
                Proof: The fact that we can construct a tree using the sets
                <span class="arithmatex">\(endpos\)</span> follows directly from
                Lemma 2 (that any two sets either do not intersect or one is
                contained in the other).
              </p>
              <p>
                Let us now consider an arbitrary state
                <span class="arithmatex">\(v \ne t_0\)</span>, and its suffix
                link <span class="arithmatex">\(link(v)\)</span>. From the
                definition of the suffix link and from Lemma 2 it follows that
              </p>
              <div class="arithmatex">
                \[endpos(v) \subseteq endpos(link(v)),\]
              </div>
              <p>
                which together with the previous lemma proves the assertion: the
                tree of suffix links is essentially a tree of sets
                <span class="arithmatex">\(endpos\)</span>.
              </p>
              <p>
                Here is an <strong>example</strong> of a tree of suffix links in
                the suffix automaton build for the string
                <span class="arithmatex">\(\text{"abcbc"}\)</span>. The nodes
                are labeled with the longest substring from the corresponding
                equivalence class.
              </p>
              <p>
                <img
                  alt='Suffix automaton for "abcbc" with suffix links'
                  src="SA_suffix_links.png"
                />
              </p>
              <h3 id="recap">Recap</h3>
              <p>
                Before proceeding to the algorithm itself, we recap the
                accumulated knowledge, and introduce a few auxiliary notations.
              </p>
              <ul>
                <li>
                  The substrings of the string
                  <span class="arithmatex">\(s\)</span> can be decomposed into
                  equivalence classes according to their end positions
                  <span class="arithmatex">\(endpos\)</span>.
                </li>
                <li>
                  The suffix automaton consists of the initial state
                  <span class="arithmatex">\(t_0\)</span>, as well as of one
                  state for each
                  <span class="arithmatex">\(endpos\)</span>-equivalence class.
                </li>
                <li>
                  For each state <span class="arithmatex">\(v\)</span> one or
                  multiple substrings match. We denote by
                  <span class="arithmatex">\(longest(v)\)</span> the longest
                  such string, and through
                  <span class="arithmatex">\(len(v)\)</span> its length. We
                  denote by <span class="arithmatex">\(shortest(v)\)</span> the
                  shortest such substring, and its length with
                  <span class="arithmatex">\(minlen(v)\)</span>. Then all the
                  strings corresponding to this state are different suffixes of
                  the string <span class="arithmatex">\(longest(v)\)</span> and
                  have all possible lengths in the interval
                  <span class="arithmatex">\([minlength(v); len(v)]\)</span>.
                </li>
                <li>
                  For each state <span class="arithmatex">\(v \ne t_0\)</span> a
                  suffix link is defined as a link, that leads to a state that
                  corresponds to the suffix of the string
                  <span class="arithmatex">\(longest(v)\)</span> of length
                  <span class="arithmatex">\(minlen(v) - 1\)</span>. The suffix
                  links form a tree with the root in
                  <span class="arithmatex">\(t_0\)</span>, and at the same time
                  this tree forms an inclusion relationship between the sets
                  <span class="arithmatex">\(endpos\)</span>.
                </li>
                <li>
                  We can express
                  <span class="arithmatex">\(minlen(v)\)</span> for
                  <span class="arithmatex">\(v \ne t_0\)</span> using the suffix
                  link <span class="arithmatex">\(link(v)\)</span> as:
                </li>
              </ul>
              <div class="arithmatex">\[minlen(v) = len(link(v)) + 1\]</div>
              <ul>
                <li>
                  If we start from an arbitrary state
                  <span class="arithmatex">\(v_0\)</span> and follow the suffix
                  links, then sooner or later we will reach the initial state
                  <span class="arithmatex">\(t_0\)</span>. In this case we
                  obtain a sequence of disjoint intervals
                  <span class="arithmatex">\([minlen(v_i); len(v_i)]\)</span>,
                  which in union forms the continuous interval
                  <span class="arithmatex">\([0; len(v_0)]\)</span>.
                </li>
              </ul>
              <h3 id="algorithm">Algorithm</h3>
              <p>
                Now we can proceed to the algorithm itself. The algorithm will
                be <strong>online</strong>, i.e. we will add the characters of
                the string one by one, and modify the automaton accordingly in
                each step.
              </p>
              <p>
                To achieve linear memory consumption, we will only store the
                values <span class="arithmatex">\(len\)</span>,
                <span class="arithmatex">\(link\)</span> and a list of
                transitions in each state. We will not label terminal states
                (but we will later show how to arrange these labels after
                constructing the suffix automaton).
              </p>
              <p>
                Initially the automaton consists of a single state
                <span class="arithmatex">\(t_0\)</span>, which will be the index
                <span class="arithmatex">\(0\)</span> (the remaining states will
                receive the indices
                <span class="arithmatex">\(1, 2, \dots\)</span>). We assign it
                <span class="arithmatex">\(len = 0\)</span> and
                <span class="arithmatex">\(link = -1\)</span> for convenience
                (<span class="arithmatex">\(-1\)</span> will be a fictional,
                non-existing state).
              </p>
              <p>
                Now the whole task boils down to implementing the process of
                <strong>adding one character</strong>
                <span class="arithmatex">\(c\)</span> to the end of the current
                string. Let us describe this process:
              </p>
              <ul>
                <li>
                  Let <span class="arithmatex">\(last\)</span> be the state
                  corresponding to the entire string before adding the character
                  <span class="arithmatex">\(c\)</span>. (Initially we set
                  <span class="arithmatex">\(last = 0\)</span>, and we will
                  change <span class="arithmatex">\(last\)</span> in the last
                  step of the algorithm accordingly.)
                </li>
                <li>
                  Create a new state <span class="arithmatex">\(cur\)</span>,
                  and assign it with
                  <span class="arithmatex">\(len(cur) = len(last) + 1\)</span>.
                  The value <span class="arithmatex">\(link(cur)\)</span> is not
                  known at the time.
                </li>
                <li>
                  Now we to the following procedure: We start at the state
                  <span class="arithmatex">\(last\)</span>. While there isn't a
                  transition through the letter
                  <span class="arithmatex">\(c\)</span>, we will add a
                  transition to the state
                  <span class="arithmatex">\(cur\)</span>, and follow the suffix
                  link. If at some point there already exists a transition
                  through the letter <span class="arithmatex">\(c\)</span>, then
                  we will stop and denote this state with
                  <span class="arithmatex">\(p\)</span>.
                </li>
                <li>
                  If it haven't found such a state
                  <span class="arithmatex">\(p\)</span>, then we reached the
                  fictitious state <span class="arithmatex">\(-1\)</span>, then
                  we can just assign
                  <span class="arithmatex">\(link(cur) = 0\)</span> and leave.
                </li>
                <li>
                  Suppose now that we have found a state
                  <span class="arithmatex">\(p\)</span>, from which there exists
                  a transition through the letter
                  <span class="arithmatex">\(c\)</span>. We will denote the
                  state, to which the transition leads, with
                  <span class="arithmatex">\(q\)</span>.
                </li>
                <li>
                  Now we have two cases. Either
                  <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>, or
                  not.
                </li>
                <li>
                  If <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>,
                  then we can simply assign
                  <span class="arithmatex">\(link(cur) = q\)</span> and leave.
                </li>
                <li>
                  <p>
                    Otherwise it is a bit more complicated. It is necessary to
                    <strong>clone</strong> the state
                    <span class="arithmatex">\(q\)</span>: we create a new state
                    <span class="arithmatex">\(clone\)</span>, copy all the data
                    from <span class="arithmatex">\(q\)</span> (suffix link and
                    transition) except the value
                    <span class="arithmatex">\(len\)</span>. We will assign
                    <span class="arithmatex">\(len(clone) = len(p) + 1\)</span>.
                  </p>
                  <p>
                    After cloning we direct the suffix link from
                    <span class="arithmatex">\(cur\)</span> to
                    <span class="arithmatex">\(clone\)</span>, and also from
                    <span class="arithmatex">\(q\)</span> to clone.
                  </p>
                  <p>
                    Finally we need to walk from the state
                    <span class="arithmatex">\(p\)</span> back using suffix
                    links as long as there is a transition through
                    <span class="arithmatex">\(c\)</span> to the state
                    <span class="arithmatex">\(q\)</span>, and redirect all
                    those to the state
                    <span class="arithmatex">\(clone\)</span>. - In any of the
                    three cases, after completing the procedure, we update the
                    value <span class="arithmatex">\(last\)</span> with the
                    state <span class="arithmatex">\(cur\)</span>.
                  </p>
                </li>
              </ul>
              <p>
                If we also want to know which states are
                <strong>terminal</strong> and which are not, the we can find all
                terminal states after constructing the complete suffix automaton
                for the entire string <span class="arithmatex">\(s\)</span>. To
                do this, we take the state corresponding to the entire string
                (stored in the variable
                <span class="arithmatex">\(last\)</span>), and follow its suffix
                links until we reach the initial state. We will mark all visited
                states as terminal. It is easy to understand that by doing so we
                will mark exactly the states corresponding to all the suffixes
                of the string <span class="arithmatex">\(s\)</span>, which are
                exactly the terminal states.
              </p>
              <p>
                In the next section we will look in detail at each step and show
                its <strong>correctness</strong>.
              </p>
              <p>
                Here we only note that, since we only create one or two new
                states for each character of
                <span class="arithmatex">\(s\)</span>, the suffix automaton
                contains a <strong>linear number of states</strong>.
              </p>
              <p>
                The linearity of the number of transitions, and in general the
                linearity of the runtime of the algorithm is less clear, and
                they will be proven after we proved the correctness.
              </p>
              <h3 id="correctness">Correctness</h3>
              <ul>
                <li>
                  <p>
                    We will call a transition
                    <span class="arithmatex">\((p, q)\)</span>
                    <strong>continuous</strong> if
                    <span class="arithmatex">\(len(p) + 1 = len(q)\)</span>.
                    Otherwise, i.e. when
                    <span class="arithmatex">\(len(p) + 1 &lt; len(q)\)</span>,
                    the transition will be called
                    <strong>non-continuous</strong>.
                  </p>
                  <p>
                    As we can see from the description of the algorithm,
                    continuous and non-continuous transitions will lead to
                    different cases of the algorithm. Continuous transitions are
                    fixed, and will never change again. In contrast
                    non-continuous transition may change, when new letters are
                    added to the string (the end of the transition edge may
                    change).
                  </p>
                </li>
                <li>
                  <p>
                    To avoid ambiguity we will denote the string, for which the
                    suffix automaton was built before adding the current
                    character <span class="arithmatex">\(c\)</span>, with
                    <span class="arithmatex">\(s\)</span>.
                  </p>
                </li>
                <li>
                  <p>
                    The algorithm begins with creating a new state
                    <span class="arithmatex">\(cur\)</span>, which will
                    correspond to the entire string
                    <span class="arithmatex">\(s + c\)</span>. It is clear why
                    we have to create a new state. Together with the new
                    character a new equivalence class is created.
                  </p>
                </li>
                <li>
                  <p>
                    After creating a new state we traverse by suffix links
                    starting from the state corresponding to the entire string
                    <span class="arithmatex">\(s\)</span>. For each state we try
                    to add a transition with the character
                    <span class="arithmatex">\(c\)</span> to the new state
                    <span class="arithmatex">\(cur\)</span>. Thus we append to
                    each suffix of <span class="arithmatex">\(s\)</span> the
                    character <span class="arithmatex">\(c\)</span>. However we
                    can only add these new transitions, if they don't conflict
                    with an already existing one. Therefore as soon as we find
                    an already existing transition with
                    <span class="arithmatex">\(c\)</span> we have to stop.
                  </p>
                </li>
                <li>
                  <p>
                    In the simplest case we reached the fictitious state
                    <span class="arithmatex">\(-1\)</span>. This means we added
                    the transition with <span class="arithmatex">\(c\)</span> to
                    all suffixes of <span class="arithmatex">\(s\)</span>. This
                    also means, that the character
                    <span class="arithmatex">\(c\)</span> hasn't been part of
                    the string <span class="arithmatex">\(s\)</span> before.
                    Therefore the suffix link of
                    <span class="arithmatex">\(cur\)</span> has to lead to the
                    state <span class="arithmatex">\(0\)</span>.
                  </p>
                </li>
                <li>
                  <p>
                    In the second case we came across an existing transition
                    <span class="arithmatex">\((p, q)\)</span>. This means that
                    we tried to add a string
                    <span class="arithmatex">\(x + c\)</span> (where
                    <span class="arithmatex">\(x\)</span> is a suffix of
                    <span class="arithmatex">\(s\)</span>) to the machine that
                    <strong>already exists</strong> in the machine (the string
                    <span class="arithmatex">\(x + c\)</span> already appears as
                    a substring of <span class="arithmatex">\(s\)</span>). Since
                    we assume that the automaton for the string
                    <span class="arithmatex">\(s\)</span> is build correctly, we
                    should not add a new transition here.
                  </p>
                  <p>
                    However there is a difficulty. To which state should the
                    suffix link from the state
                    <span class="arithmatex">\(cur\)</span> lead? We have to
                    make a suffix link to a state, in which the longest string
                    is exactly <span class="arithmatex">\(x + c\)</span>, i.e.
                    the <span class="arithmatex">\(len\)</span> of this state
                    should be <span class="arithmatex">\(len(p) + 1\)</span>.
                    However it is possible, that such a state doesn't yet
                    exists, i.e.
                    <span class="arithmatex">\(len(q) &gt; len(p) + 1\)</span>.
                    In this case we have to create such a state, by
                    <strong>splitting</strong> the state
                    <span class="arithmatex">\(q\)</span>.
                  </p>
                </li>
                <li>
                  <p>
                    If the transition
                    <span class="arithmatex">\((p, q)\)</span> turns out to be
                    continuous, then
                    <span class="arithmatex">\(len(q) = len(p) + 1\)</span>. In
                    this case everything is simple. We direct the suffix link
                    from <span class="arithmatex">\(cur\)</span> to the state
                    <span class="arithmatex">\(q\)</span>.
                  </p>
                </li>
                <li>
                  <p>
                    Otherwise the transition is non-continuous, i.e.
                    <span class="arithmatex">\(len(q) &gt; len(p) + 1\)</span>.
                    This means that the state
                    <span class="arithmatex">\(q\)</span> corresponds to not
                    only the suffix of
                    <span class="arithmatex">\(s + c\)</span> with length
                    <span class="arithmatex">\(len(p) + 1\)</span>, but also to
                    longer substrings of <span class="arithmatex">\(s\)</span>.
                    We can do nothing other than <strong>splitting</strong> the
                    state <span class="arithmatex">\(q\)</span> into two
                    sub-states, so that the first one has length
                    <span class="arithmatex">\(len(p) + 1\)</span>.
                  </p>
                  <p>
                    How can we split a state? We <strong>clone</strong> the
                    state <span class="arithmatex">\(q\)</span>, which gives us
                    the state <span class="arithmatex">\(clone\)</span>, and we
                    set
                    <span class="arithmatex">\(len(clone) = len(p) + 1\)</span>.
                    We copy all the transitions from
                    <span class="arithmatex">\(q\)</span> to
                    <span class="arithmatex">\(clone\)</span>, because we don't
                    want to change the paths that traverse through
                    <span class="arithmatex">\(q\)</span>. Also we set the
                    suffix link from
                    <span class="arithmatex">\(clone\)</span> to the target of
                    the suffix link of <span class="arithmatex">\(q\)</span>,
                    and set the suffix link of
                    <span class="arithmatex">\(q\)</span> to
                    <span class="arithmatex">\(clone\)</span>.
                  </p>
                  <p>
                    And after splitting the state, we set the suffix link from
                    <span class="arithmatex">\(cur\)</span> to
                    <span class="arithmatex">\(clone\)</span>.
                  </p>
                  <p>
                    In the last step we change some of the transitions to
                    <span class="arithmatex">\(q\)</span>, we redirect them to
                    <span class="arithmatex">\(clone\)</span>. Which transitions
                    do we have to change? It is enough to redirect only the
                    transitions corresponding to all the suffixes of the string
                    <span class="arithmatex">\(w + c\)</span> (where
                    <span class="arithmatex">\(w\)</span> is the longest string
                    of <span class="arithmatex">\(p\)</span>), i.e. we need to
                    continue to move along the suffix links, starting from the
                    vertex <span class="arithmatex">\(p\)</span> until we reach
                    the fictitious state
                    <span class="arithmatex">\(-1\)</span> or a transition that
                    leads to a different state than
                    <span class="arithmatex">\(q\)</span>.
                  </p>
                </li>
              </ul>
              <h3 id="linear-number-of-operations">
                Linear number of operations
              </h3>
              <p>
                First we immediately make the assumption that the size of the
                alphabet is <strong>constant</strong>. If this is not the case,
                then it will not be possible to talk about the linear time
                complexity. The list of transitions from one vertex will be
                stored in a balanced tree, which allows you to quickly perform
                key search operations and adding keys. Therefore if we denote
                with <span class="arithmatex">\(k\)</span> the size of the
                alphabet, then the asymptotic behavior of the algorithm will be
                <span class="arithmatex">\(O(n \log k)\)</span> with
                <span class="arithmatex">\(O(n)\)</span> memory. However if the
                alphabet is small enough, then you can sacrifice memory by
                avoiding balanced trees, and store the transitions at each
                vertex as an array of length
                <span class="arithmatex">\(k\)</span> (for quick searching by
                key) and a dynamic list (to quickly traverse all available
                keys). Thus we reach the
                <span class="arithmatex">\(O(n)\)</span> time complexity for the
                algorithm, but at a cost of
                <span class="arithmatex">\(O(n k)\)</span> memory complexity.
              </p>
              <p>
                So we will consider the size of the alphabet to be constant,
                i.e. each operation of searching for a transition on a
                character, adding a transition, searching for the next
                transition - all these operations can be done in
                <span class="arithmatex">\(O(1)\)</span>.
              </p>
              <p>
                If we consider all parts of the algorithm, then it contains
                three places in the algorithm in which the linear complexity is
                not obvious:
              </p>
              <ul>
                <li>
                  The first place is the traversal through the suffix links from
                  the state <span class="arithmatex">\(last\)</span>, adding
                  transitions with the character
                  <span class="arithmatex">\(c\)</span>.
                </li>
                <li>
                  The second place is the copying of transitions when the state
                  <span class="arithmatex">\(q\)</span> is cloned into a new
                  state <span class="arithmatex">\(clone\)</span>.
                </li>
                <li>
                  Third place is changing the transition leading to
                  <span class="arithmatex">\(q\)</span>, redirecting them to
                  <span class="arithmatex">\(clone\)</span>.
                </li>
              </ul>
              <p>
                We use the fact that the size of the suffix automaton (both in
                number of states and in the number of transitions) is
                <strong>linear</strong>. (The proof of the linearity of the
                number of states is the algorithm itself, and the proof of
                linearity of the number of states is given below, after the
                implementation of the algorithm).
              </p>
              <p>
                Thus the total complexity of the
                <strong>first and second places</strong> is obvious, after all
                each operation adds only one amortized new transition to the
                automaton.
              </p>
              <p>
                It remains to estimate the total complexity of the
                <strong>third place</strong>, in which we redirect transitions,
                that pointed originally to
                <span class="arithmatex">\(q\)</span>, to
                <span class="arithmatex">\(clone\)</span>. We denote
                <span class="arithmatex">\(v = longest(p)\)</span>. This is a
                suffix of the string <span class="arithmatex">\(s\)</span>, and
                with each iteration its length decreases - and therefore the
                position <span class="arithmatex">\(v\)</span> as the suffix of
                the string <span class="arithmatex">\(s\)</span> increases
                monotonically with each iteration. In this case, if before the
                first iteration of the loop, the corresponding string
                <span class="arithmatex">\(v\)</span> was at the depth
                <span class="arithmatex">\(k\)</span> (<span class="arithmatex"
                  >\(k \ge 2\)</span
                >) from <span class="arithmatex">\(last\)</span> (by counting
                the depth as the number of suffix links), then after the last
                iteration the string
                <span class="arithmatex">\(v + c\)</span> will be a
                <span class="arithmatex">\(2\)</span>-th suffix link on the path
                from <span class="arithmatex">\(cur\)</span> (which will become
                the new value <span class="arithmatex">\(last\)</span>).
              </p>
              <p>
                Thus, each iteration of this loop leads to the fact that the
                position of the string
                <span class="arithmatex">\(longest(link(link(last))\)</span> as
                suffix of the current string will monotonically increase.
                Therefore this cycle cannot be executed more than
                <span class="arithmatex">\(n\)</span> iterations, which was
                required to prove.
              </p>
              <h3 id="implementation">Implementation</h3>
              <p>
                First we describe a data structure that will store all
                information about a specific transition (<span
                  class="arithmatex"
                  >\(len\)</span
                >, <span class="arithmatex">\(link\)</span> and the list of
                transitions). If necessary you can add a terminal flag here, as
                well as other information. We will store the list of transitions
                in the form of a <span class="arithmatex">\(map\)</span>, which
                allows us to achieve total
                <span class="arithmatex">\(O(n)\)</span> memory and
                <span class="arithmatex">\(O(n \log k)\)</span> time for
                processing the entire string.
              </p>
              <div class="highlight">
                <pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre>
              </div>
              <p>
                The suffix automaton itself will be stored in an array of these
                structures <span class="arithmatex">\(state\)</span>. We store
                the current size <span class="arithmatex">\(sz\)</span> and also
                the variable <span class="arithmatex">\(last\)</span>, the state
                corresponding to the entire string at the moment.
              </p>
              <div class="highlight">
                <pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAXLEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"></span>
<span class="n">state</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">MAXLEN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
</code></pre>
              </div>
              <p>
                We give a function that initializes a suffix automaton (creating
                a suffix automaton with a single state).
              </p>
              <div class="highlight">
                <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sa_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre>
              </div>
              <p>
                And finally we give the implementation of the main function -
                which adds the next character to the end of the current line,
                rebuilding the machine accordingly.
              </p>
              <div class="highlight">
                <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sa_extend</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">last</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">clone</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">link</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">q</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clone</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre>
              </div>
              <p>
                As mentioned above, if you sacrifice memory (<span
                  class="arithmatex"
                  >\(O(n k)\)</span
                >, where <span class="arithmatex">\(k\)</span> is the size of
                the alphabet), then you can achieve the build time of the
                machine in <span class="arithmatex">\(O(n)\)</span>, even for
                any alphabet size <span class="arithmatex">\(k\)</span>. But for
                this you will have to store an array of size
                <span class="arithmatex">\(k\)</span> in each state (for quickly
                jumping to the transition of the letter), and additional a list
                of all transitions (to quickly iterate over the transitions
                them).
              </p>
              <h2 id="additional-properties">Additional properties</h2>
              <h3 id="number-of-states">Number of states</h3>
              <p>
                The number of states in a suffix automaton of the string
                <span class="arithmatex">\(s\)</span> of length
                <span class="arithmatex">\(n\)</span>
                <strong>doesn't exceed</strong>
                <span class="arithmatex">\(2n - 1\)</span> (for
                <span class="arithmatex">\(n \ge 2\)</span>).
              </p>
              <p>
                The proof is the construction algorithm itself, since initially
                the automaton consists of one state, and in the first and second
                iteration only a single state will be created, and in the
                remaining <span class="arithmatex">\(n-2\)</span> steps at most
                <span class="arithmatex">\(2\)</span> states will be created
                each.
              </p>
              <p>
                However we can also <strong>show</strong> this estimation
                <strong>without knowing the algorithm</strong>. Let us recall
                that the number of states is equal to the number of different
                sets <span class="arithmatex">\(endpos\)</span>. In addition
                theses sets <span class="arithmatex">\(endpos\)</span> form a
                tree (a parent vertex contains all children sets in his set).
                Consider this tree and transform it a little bit: as long as it
                has an internal vertex with only one child (which means that the
                set of the child misses at least one position from the parent
                set), we create a new child with the set of the missing
                positions. In the end we have a tree in which each inner vertex
                has a degree greater than one, and the number of leaves does not
                exceed <span class="arithmatex">\(n\)</span>. Therefore there
                are no more than
                <span class="arithmatex">\(2n - 1\)</span> vertices in such a
                tree.
              </p>
              <p>
                This bound of the number of states can actually be achieved for
                each <span class="arithmatex">\(n\)</span>. A possible string
                is:
              </p>
              <div class="arithmatex">\[\text{"abbb}\dots \text{bbb"}\]</div>
              <p>
                In each iteration, starting at the third one, the algorithm will
                split a state, resulting in exactly
                <span class="arithmatex">\(2n - 1\)</span> states.
              </p>
              <h3 id="number-of-transitions">Number of transitions</h3>
              <p>
                The number of transitions in a suffix automaton of a string
                <span class="arithmatex">\(s\)</span> of length
                <span class="arithmatex">\(n\)</span>
                <strong>doesn't exceed</strong>
                <span class="arithmatex">\(3n - 4\)</span> (for
                <span class="arithmatex">\(n \ge 3\)</span>).
              </p>
              <p>Let us prove this:</p>
              <p>
                Let us first estimate the number of continuous transitions.
                Consider a spanning tree of the longest paths in the automaton
                starting in the state <span class="arithmatex">\(t_0\)</span>.
                This skeleton will consist of only the continuous edges, and
                therefore their number is less than the number of states, i.e.
                it does not exceed <span class="arithmatex">\(2n - 2\)</span>.
              </p>
              <p>
                Now let us estimate the number of non-continuous transitions.
                Let the current non-continuous transition be
                <span class="arithmatex">\((p, q)\)</span> with the character
                <span class="arithmatex">\(c\)</span>. We take the correspondent
                string <span class="arithmatex">\(u + c + w\)</span>, where the
                string <span class="arithmatex">\(u\)</span> corresponds to the
                longest path from the initial state to
                <span class="arithmatex">\(p\)</span>, and
                <span class="arithmatex">\(w\)</span> to the longest path from
                <span class="arithmatex">\(q\)</span> to any terminal state. On
                one hand, each such string
                <span class="arithmatex">\(u + c + w\)</span> for each
                incomplete strings will be different (since the strings
                <span class="arithmatex">\(u\)</span> and
                <span class="arithmatex">\(w\)</span> are formed only by
                complete transitions). On the other hand each such string
                <span class="arithmatex">\(u + c + w\)</span>, by the definition
                of the terminal states, will be a suffix of the entire string
                <span class="arithmatex">\(s\)</span>. Since there are only
                <span class="arithmatex">\(n\)</span> non-empty suffixes of
                <span class="arithmatex">\(s\)</span>, and non of the strings
                <span class="arithmatex">\(u + c + w\)</span> can contain
                <span class="arithmatex">\(s\)</span> (because the entire string
                only contains complete transitions), the total number of
                incomplete transitions does not exceed
                <span class="arithmatex">\(n - 1\)</span>.
              </p>
              <p>
                Combining these two estimates gives us the bound
                <span class="arithmatex">\(3n - 3\)</span>. However, since the
                maximum number of states can only be achieved with the test case
                <span class="arithmatex">\(\text{"abbb\dots bbb"}\)</span> and
                this case has clearly less than
                <span class="arithmatex">\(3n - 3\)</span> transitions, we get
                the tighter bound of
                <span class="arithmatex">\(3n - 4\)</span> for the number of
                transitions in a suffix automaton.
              </p>
              <p>This bound can also be achieved with the string:</p>
              <div class="arithmatex">\[\text{"abbb}\dots \text{bbbc"}\]</div>
              <h2 id="applications">Applications</h2>
              <p>
                Here we look at some tasks that can be solved using the suffix
                automaton. For the simplicity we assume that the alphabet size
                <span class="arithmatex">\(k\)</span> is constant, which allows
                us to consider the complexity of appending a character and the
                traversal as constant.
              </p>
              <h3 id="check-for-occurrence">Check for occurrence</h3>
              <p>
                Given a text <span class="arithmatex">\(T\)</span>, and multiple
                patters <span class="arithmatex">\(P\)</span>. We have to check
                whether or not the strings
                <span class="arithmatex">\(P\)</span> appear as a substring of
                <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                We build a suffix automaton of the text
                <span class="arithmatex">\(T\)</span> in
                <span class="arithmatex">\(O(length(T))\)</span> time. To check
                if a pattern <span class="arithmatex">\(P\)</span> appears in
                <span class="arithmatex">\(T\)</span>, we follow the
                transitions, starting from
                <span class="arithmatex">\(t_0\)</span>, according to the
                characters of <span class="arithmatex">\(P\)</span>. If at some
                point there doesn't exists a transition, then the pattern
                <span class="arithmatex">\(P\)</span> doesn't appear as a
                substring of <span class="arithmatex">\(T\)</span>. If we can
                process the entire string
                <span class="arithmatex">\(P\)</span> this way, then the string
                appears in <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                It is clear that this will take
                <span class="arithmatex">\(O(length(P))\)</span> time for each
                string <span class="arithmatex">\(P\)</span>. Moreover the
                algorithm actually finds the length of the longest prefix of
                <span class="arithmatex">\(P\)</span> that appears in the text.
              </p>
              <h3 id="number-of-different-substrings">
                Number of different substrings
              </h3>
              <p>
                Given a string <span class="arithmatex">\(S\)</span>. You want
                to compute the number of different substrings.
              </p>
              <p>
                Let us build a suffix automaton for the string
                <span class="arithmatex">\(S\)</span>.
              </p>
              <p>
                Each substring of
                <span class="arithmatex">\(S\)</span> corresponds to some path
                in the automaton. Therefore the number of different substrings
                is equal to the number of different paths in the automaton
                starting at <span class="arithmatex">\(t_0\)</span>.
              </p>
              <p>
                Given that the suffix automaton is a directed acyclic graph, the
                number of different ways can be computed using dynamic
                programming.
              </p>
              <p>
                Namely, let <span class="arithmatex">\(d[v]\)</span> be the
                number of ways, starting at the state
                <span class="arithmatex">\(v\)</span> (including the path of
                length zero). Then we have the recursion:
              </p>
              <div class="arithmatex">
                \[d[v] = 1 + \sum_{w : (v, w, c) \in DAWG} d[w]\]
              </div>
              <p>
                I.e. <span class="arithmatex">\(d[v]\)</span> can be expressed
                as the sum of answers for all ends of the transitions of
                <span class="arithmatex">\(v\)</span>.
              </p>
              <p>
                The number of different substrings is the value
                <span class="arithmatex">\(d[t_0] - 1\)</span> (since we don't
                count the empty substring).
              </p>
              <p>
                Total time complexity:
                <span class="arithmatex">\(O(length(S))\)</span>
              </p>
              <h3 id="total-length-of-all-different-substrings">
                Total length of all different substrings
              </h3>
              <p>
                Given a string <span class="arithmatex">\(S\)</span>. We want to
                compute the total length of all its various substrings.
              </p>
              <p>
                The solution is similar to the previous one, only now it is
                necessary to consider two quantities for the dynamic programming
                part: the number of different substrings
                <span class="arithmatex">\(d[v]\)</span> and their total length
                <span class="arithmatex">\(ans[v]\)</span>.
              </p>
              <p>
                We already described how to compute
                <span class="arithmatex">\(d[v]\)</span> in the previous task.
                The value <span class="arithmatex">\(ans[v]\)</span> can be
                computed using the recursion:
              </p>
              <div class="arithmatex">
                \[ans[v] = \sum_{w : (v, w, c) \in DAWG} d[w] + ans[w]\]
              </div>
              <p>
                We take the answer of each adjacent vertex
                <span class="arithmatex">\(w\)</span>, and add to it
                <span class="arithmatex">\(d[w]\)</span> (since every substrings
                is one character longer when starting from the state
                <span class="arithmatex">\(v\)</span>).
              </p>
              <p>
                Again this task can be computed in
                <span class="arithmatex">\(O(length(S))\)</span> time.
              </p>
              <h3 id="lexicographically-k-th-substring">
                Lexicographically <span class="arithmatex">\(k\)</span>-th
                substring
              </h3>
              <p>
                Given a string <span class="arithmatex">\(S\)</span>. We have to
                answer multiple queries. For each given number
                <span class="arithmatex">\(K_i\)</span> we have to find the
                <span class="arithmatex">\(K_i\)</span>-th string in the
                lexicographically ordered list of all substrings.
              </p>
              <p>
                The solution of this problem is based on the idea of the
                previous two problems. The lexicographically
                <span class="arithmatex">\(k\)</span>-th substring corresponds
                to the lexicographically
                <span class="arithmatex">\(k\)</span>-th path in the suffix
                automaton. Therefore after counting the number of paths from
                each state, we can easily search for the
                <span class="arithmatex">\(k\)</span>-th path starting from the
                root of the automaton.
              </p>
              <p>
                This takes <span class="arithmatex">\(O(length(S))\)</span> time
                for preprocessing and then
                <span class="arithmatex">\(O(length(ans) \cdot k)\)</span> for
                each query (where <span class="arithmatex">\(ans\)</span> is the
                answer for the query and
                <span class="arithmatex">\(k\)</span> is the size of the
                alphabet).
              </p>
              <h3 id="smallest-cyclic-shift">Smallest cyclic shift</h3>
              <p>
                Given a string <span class="arithmatex">\(S\)</span>. We want to
                find the lexicographically smallest cyclic shift.
              </p>
              <p>
                We construct a suffix automaton for the string
                <span class="arithmatex">\(S + S\)</span>. Then the automaton
                will contain in itself as paths all the cyclic shifts of the
                string <span class="arithmatex">\(S\)</span>.
              </p>
              <p>
                Consequently the problem is reduced to finding the
                lexicographically smallest path of length
                <span class="arithmatex">\(length(S)\)</span>, which can be done
                in a trivial way: we start in the initial state and greedily
                pass through the transitions with the minimal character.
              </p>
              <p>
                Total time complexity is
                <span class="arithmatex">\(O(length(S))\)</span>.
              </p>
              <h3 id="number-of-occurrences">Number of occurrences</h3>
              <p>
                For a given text <span class="arithmatex">\(T\)</span>. We have
                to answer multiple queries. For each given pattern
                <span class="arithmatex">\(P\)</span> we have to find out how
                many times the string
                <span class="arithmatex">\(P\)</span> appears in the string
                <span class="arithmatex">\(T\)</span> as substring.
              </p>
              <p>
                We construct the suffix automaton for the text
                <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                Next we do the following preprocessing: for each state
                <span class="arithmatex">\(v\)</span> in the automaton we
                calculate the number
                <span class="arithmatex">\(cnt[v]\)</span> that is equal to the
                size of the set <span class="arithmatex">\(endpos(v)\)</span>.
                In fact all strings corresponding to the same state
                <span class="arithmatex">\(v\)</span> appear in the text
                <span class="arithmatex">\(T\)</span> an equal amount of times,
                which is equal to the number of positions in the set
                <span class="arithmatex">\(endpos\)</span>.
              </p>
              <p>
                However we cannot construct the sets
                <span class="arithmatex">\(endpos\)</span> explicitly, therefore
                we only consider their sizes
                <span class="arithmatex">\(cnt\)</span>.
              </p>
              <p>
                To compute them we proceed as follows. For each state, if it was
                not created by cloning (and if it is not the initial state
                <span class="arithmatex">\(t_0\)</span>), we initialize it with
                <span class="arithmatex">\(cnt = 1\)</span>. Then we will go
                through all states in decreasing order of their length
                <span class="arithmatex">\(len\)</span>, and add the current
                value <span class="arithmatex">\(cnt[v]\)</span> to the suffix
                links:
              </p>
              <div class="arithmatex">\[cnt[link(v)] \text{ += } cnt[v]\]</div>
              <p>This gives the correct value for each state.</p>
              <p>
                Why is this correct? The total stats obtained not obtained by
                cloning are exactly
                <span class="arithmatex">\(length(T)\)</span>, and the first
                <span class="arithmatex">\(i\)</span> of them appeared when we
                added the first
                <span class="arithmatex">\(i\)</span> characters. Consequently
                for each of these states we count the corresponding position at
                which it was processed. Therefore initially we have
                <span class="arithmatex">\(cnt = 1\)</span> for each such state,
                and <span class="arithmatex">\(cnt = 0\)</span> for all other.
              </p>
              <p>
                Then we apply the following operation for each
                <span class="arithmatex">\(v\)</span>:
                <span class="arithmatex"
                  >\(cnt[link(v)] \text{ += } cnt[v]\)</span
                >. The meaning behind this is, that if a string
                <span class="arithmatex">\(v\)</span> appears
                <span class="arithmatex">\(cnt[v]\)</span> times, then also all
                its suffixes appear at the exact same end positions, therefore
                also <span class="arithmatex">\(cnt[v]\)</span> times.
              </p>
              <p>
                Why don't we overcount in this procedure (i.e. don't count some
                position twice)? Because we add the positions of a state to only
                one other state, so it can not happen that one state directs its
                positions to another state twice in two different ways.
              </p>
              <p>
                Thus we can compute the quantities
                <span class="arithmatex">\(cnt\)</span> for all states in the
                automaton in
                <span class="arithmatex">\(O(length(T))\)</span> time.
              </p>
              <p>
                After that answering a query by just looking up the value
                <span class="arithmatex">\(cnt[t]\)</span>, where
                <span class="arithmatex">\(t\)</span> is the state corresponding
                to the pattern, if such a state exists. Otherwise answer with
                <span class="arithmatex">\(0\)</span>. Answering a query takes
                <span class="arithmatex">\(O(length(P))\)</span> time.
              </p>
              <h3 id="first-occurrence-position">First occurrence position</h3>
              <p>
                Given a text <span class="arithmatex">\(T\)</span> and multiple
                queries. For each query string
                <span class="arithmatex">\(P\)</span> we want to find the
                position of the first occurrence of
                <span class="arithmatex">\(P\)</span> in the string
                <span class="arithmatex">\(T\)</span> (the position of the
                beginning of <span class="arithmatex">\(P\)</span>).
              </p>
              <p>
                We again construct a suffix automaton. Additionally we
                precompute the position
                <span class="arithmatex">\(firstpos\)</span> for all states in
                the automaton, i.e. for each state
                <span class="arithmatex">\(v\)</span> we want to find the
                position <span class="arithmatex">\(firstpos[v]\)</span> of the
                end of the first occurrence. In other words, we want to find in
                advance the minimal element of each set
                <span class="arithmatex">\(endpos\)</span> (since obviously
                cannot maintain all sets
                <span class="arithmatex">\(endpos\)</span> explicitly).
              </p>
              <p>
                To maintain these positions
                <span class="arithmatex">\(firstpos\)</span> we extend the
                function <code>sa_extend()</code>. When we create a new state
                <span class="arithmatex">\(cur\)</span>, we set:
              </p>
              <div class="arithmatex">\[firstpos(cur) = len(cur) - 1\]</div>
              <p>
                And when we clone a vertex
                <span class="arithmatex">\(q\)</span> as
                <span class="arithmatex">\(clone\)</span>, we set:
              </p>
              <div class="arithmatex">\[firstpos(clone) = firstpos(q)\]</div>
              <p>
                (since the only other option for a value would be
                <span class="arithmatex">\(firstpos(cur)\)</span> which is
                definitely too big)
              </p>
              <p>
                Thus the answer for a query is simply
                <span class="arithmatex">\(firstpos(t) - length(P) + 1\)</span>,
                where <span class="arithmatex">\(t\)</span> is the state
                corresponding to the string
                <span class="arithmatex">\(P\)</span>. Answering a query again
                takes only
                <span class="arithmatex">\(O(length(P))\)</span> time.
              </p>
              <h3 id="all-occurrence-positions">All occurrence positions</h3>
              <p>
                This time we have to display all positions of the occurrences in
                the string <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                Again we construct a suffix automaton for the text
                <span class="arithmatex">\(T\)</span>. Similar as in the
                previous task we compute the position
                <span class="arithmatex">\(firstpos\)</span> for all states.
              </p>
              <p>
                Clearly <span class="arithmatex">\(firstpos(t)\)</span> is part
                of the answer, if <span class="arithmatex">\(t\)</span> is the
                state corresponding to a query string
                <span class="arithmatex">\(P\)</span>. So we took into account
                the state of the automaton containing
                <span class="arithmatex">\(P\)</span>. What other states do we
                need to take into account? All states that correspond to strings
                for which <span class="arithmatex">\(P\)</span> is a suffix. In
                other words we need to find all the states that can reach the
                state <span class="arithmatex">\(t\)</span> via suffix links.
              </p>
              <p>
                Therefore to solve the problem we need to save for each state a
                list of suffix references leading to it. The answer to the query
                then will then contain all
                <span class="arithmatex">\(firstpos\)</span> for each state that
                we can find on a DFS / BFS starting from the state
                <span class="arithmatex">\(t\)</span> using only the suffix
                references.
              </p>
              <p>
                This workaround will work in time
                <span class="arithmatex">\(O(answer(P))\)</span>, because we
                will not visit a state twice (because only one suffix link
                leaves each state, so there cannot be two different paths
                leading to the same state).
              </p>
              <p>
                We only must take into account that two different states can
                have the same
                <span class="arithmatex">\(firstpos\)</span> value. This happens
                if one state was obtained by cloning another. However, this
                doesn't ruin the complexity, since each state can only have at
                most one clone.
              </p>
              <p>
                Moreover, we can also get rid of the duplicate positions, if we
                don't output the positions from the cloned states. In fact a
                state, that a cloned state can reach, is also reachable from the
                original state. Thus if we remember the flag
                <code>is_cloned</code> for each state, we can simply ignore the
                cloned states and only output
                <span class="arithmatex">\(firstpos\)</span> for all other
                states.
              </p>
              <p>Here are some implementation sketches:</p>
              <div class="highlight">
                <pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_clone</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">first_pos</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inv_link</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// after constructing the automaton</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">link</span><span class="p">].</span><span class="n">inv_link</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// output all positions of occurrences</span>
<span class="kt">void</span><span class="w"> </span><span class="n">output_all_occurrences</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">P_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">is_clone</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">first_pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">P_length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">inv_link</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">output_all_occurrences</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">P_length</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre>
              </div>
              <h3 id="shortest-non-appearing-string">
                Shortest non-appearing string
              </h3>
              <p>
                Given a string <span class="arithmatex">\(S\)</span> and a
                certain alphabet. We have to find a string of smallest length,
                that doesn't appear in <span class="arithmatex">\(S\)</span>.
              </p>
              <p>
                We will apply dynamic programming on the suffix automaton built
                for the string <span class="arithmatex">\(S\)</span>.
              </p>
              <p>
                Let <span class="arithmatex">\(d[v]\)</span> be the answer for
                the node <span class="arithmatex">\(v\)</span>, i.e. we already
                processed part of the substring, are currently in the state
                <span class="arithmatex">\(v\)</span>, and want to find the
                smallest number of characters that have to be added to find a
                non-existent transition. Computing
                <span class="arithmatex">\(d[v]\)</span> is very simple. If
                there is not transition using at least one character of the
                alphabet, then <span class="arithmatex">\(d[v] = 1\)</span>.
                Otherwise one character is not enough, and so we need to take
                the minimum of all answers of all transitions:
              </p>
              <div class="arithmatex">
                \[d[v] = 1 + \min_{w:(v,w,c) \in SA} d[w].\]
              </div>
              <p>
                The answer to the problem will be
                <span class="arithmatex">\(d[t_0]\)</span>, and the actual
                string can be restored using the computed array
                <span class="arithmatex">\(d[]\)</span>.
              </p>
              <h3 id="longest-common-substring-of-two-strings">
                Longest common substring of two strings
              </h3>
              <p>
                Given two strings <span class="arithmatex">\(S\)</span> and
                <span class="arithmatex">\(T\)</span>. We have to find the
                longest common substring, i.e. such a string
                <span class="arithmatex">\(X\)</span> that appears as substring
                in <span class="arithmatex">\(S\)</span> and also in
                <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                We construct a suffix automaton for the string
                <span class="arithmatex">\(S\)</span>.
              </p>
              <p>
                We will now take the string
                <span class="arithmatex">\(T\)</span>, and for each prefix look
                for the longest suffix of this prefix in
                <span class="arithmatex">\(S\)</span>. In other words, for each
                position in the string <span class="arithmatex">\(T\)</span>, we
                want to find the longest common substring of
                <span class="arithmatex">\(S\)</span> and
                <span class="arithmatex">\(T\)</span> ending in that position.
              </p>
              <p>
                For this we will use two variables, the
                <strong>current state</strong>
                <span class="arithmatex">\(v\)</span>, and the
                <strong>current length</strong>
                <span class="arithmatex">\(l\)</span>. These two variables will
                describe the current matching part: its length and the state
                that corresponds to it.
              </p>
              <p>
                Initially <span class="arithmatex">\(v = t_0\)</span> and
                <span class="arithmatex">\(l = 0\)</span>, i.e. the match is
                empty.
              </p>
              <p>
                Now let us describe how we can add a character
                <span class="arithmatex">\(T[i]\)</span> and recalculate the
                answer for it.
              </p>
              <ul>
                <li>
                  If there is a transition from
                  <span class="arithmatex">\(v\)</span> with the character
                  <span class="arithmatex">\(T[i]\)</span>, then we simply
                  follow the transition and increase
                  <span class="arithmatex">\(l\)</span> by one.
                </li>
                <li>
                  If there is no such transition, we have to shorten the current
                  matching part, which means that we need to follow the suffix
                  link: <span class="arithmatex">\(v = link(v)\)</span>. At the
                  same time, the current length has to be shortened. Obviously
                  we need to assign
                  <span class="arithmatex">\(l = len(v)\)</span>, since after
                  passing through the suffix link we end up in state whose
                  corresponding longest string is a substring.
                </li>
                <li>
                  If there is still no transition using the required character,
                  we repeat and again go through the suffix link and decrease
                  <span class="arithmatex">\(l\)</span>, until we find a
                  transition or we reach the fictional state
                  <span class="arithmatex">\(-1\)</span> (which means that the
                  symbol <span class="arithmatex">\(T[i]\)</span> doesn't appear
                  at all in <span class="arithmatex">\(S\)</span>, so we assign
                  <span class="arithmatex">\(v = l = 0\)</span>).
                </li>
              </ul>
              <p>
                The answer to the task will be the maximum of all the values
                <span class="arithmatex">\(l\)</span>.
              </p>
              <p>
                The complexity of this part is
                <span class="arithmatex">\(O(length(T))\)</span>, since in one
                move we can either increase
                <span class="arithmatex">\(l\)</span> by one, or make several
                passes through the suffix links, each one ends up reducing the
                value <span class="arithmatex">\(l\)</span>.
              </p>
              <p>Implementation:</p>
              <div class="highlight">
                <pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">lcs</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sa_init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">sa_extend</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">bestpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">link</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">length</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">next</span><span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span><span class="w"></span>
<span class="w">            </span><span class="n">l</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">best</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">bestpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">bestpos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">best</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
</code></pre>
              </div>
              <h3 id="largest-common-substring-of-multiple-strings">
                Largest common substring of multiple strings
              </h3>
              <p>
                There are <span class="arithmatex">\(k\)</span> strings
                <span class="arithmatex">\(S_i\)</span> given. We have to find
                the longest common substring, i.e. such a string
                <span class="arithmatex">\(X\)</span> that appears as substring
                in each string <span class="arithmatex">\(S_i\)</span>.
              </p>
              <p>
                We join all strings into one large string
                <span class="arithmatex">\(T\)</span>, separating the strings by
                a special characters
                <span class="arithmatex">\(D_i\)</span> (one for each string):
              </p>
              <div class="arithmatex">
                \[T = S_1 + D_1 + S_2 + D_2 + \dots + S_k + D_k.\]
              </div>
              <p>
                Then we construct the suffix automaton for the string
                <span class="arithmatex">\(T\)</span>.
              </p>
              <p>
                Now we need to find a string in the machine, which is contained
                in all the strings <span class="arithmatex">\(S_i\)</span>, and
                this can be done by using the special added characters. Note
                that if a substring is included in some string
                <span class="arithmatex">\(S_j\)</span>, then in the suffix
                automaton exists a path starting from this substring containing
                the character <span class="arithmatex">\(D_j\)</span> and not
                containing the other characters
                <span class="arithmatex"
                  >\(D_1, \dots, D_{j-1}, D_{j+1}, \dots, D_k\)</span
                >.
              </p>
              <p>
                Thus we need to calculate the attainability, which tells us for
                each state of the machine and each symbol
                <span class="arithmatex">\(D_i\)</span> if there exists such a
                path. This can easily be computed by DFS or BFS and dynamic
                programming. After that, the answer to the problem will be the
                string <span class="arithmatex">\(longest(v)\)</span> for the
                state <span class="arithmatex">\(v\)</span>, from which the
                paths were exists for all special characters.
              </p>
              <h2 id="practice-problems">Practice Problems</h2>
              <ul>
                <li>
                  <a href="https://atcoder.jp/contests/abc097/tasks/arc097_a"
                    >AtCoder - K-th Substring</a
                  >
                </li>
                <li>
                  <a href="https://www.spoj.com/problems/SUBLEX/"
                    >SPOJ - SUBLEX</a
                  >
                </li>
                <li>
                  <a href="https://codeforces.com/problemset/problem/235/C"
                    >Codeforces - Cyclical Quest</a
                  >
                </li>
                <li>
                  <a href="https://codeforces.com/contest/128/problem/B"
                    >Codeforces - String</a
                  >
                </li>
              </ul>
            </article>
          </div>
        </div>
      </main>
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">
      {
        "base": "..",
        "features": [],
        "translations": {
          "clipboard.copy": "Copy to clipboard",
          "clipboard.copied": "Copied to clipboard",
          "search.config.lang": "en",
          "search.config.pipeline": "trimmer, stopWordFilter",
          "search.config.separator": "[\\s\\-]+",
          "search.placeholder": "Search",
          "search.result.placeholder": "Type to start searching",
          "search.result.none": "No matching documents",
          "search.result.one": "1 matching document",
          "search.result.other": "# matching documents",
          "search.result.more.one": "1 more on this page",
          "search.result.more.other": "# more on this page",
          "search.result.term.missing": "Missing",
          "select.version.title": "Select version"
        },
        "search": "../assets/javascripts/workers/search.bd0b6b67.min.js"
      }
    </script>

    <script src="../assets/javascripts/bundle.467223ff.min.js"></script>

    <script src="../javascript/config.js"></script>

    <script src="../../polyfill.io/v3/polyfill.min1162.js?features=es6"></script>

    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </body>

  <!-- Mirrored from  firststeptocp.com/string/suffix-automaton.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 13 Mar 2022 18:44:43 GMT -->
</html>
